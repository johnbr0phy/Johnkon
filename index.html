import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import Toolbar from '../components/Toolbar';
import Canvas from '../components/Canvas';
import PropertiesPanel from '../components/PropertiesPanel';
// import ModuleSidebar from '../components/ModuleSidebar'; // Deferred for simplicity

// --- Mock Data ---
// In a real app, this would come from an API based on pageId or be a new template
const initialPageData = {
  id: 'new',
  name: 'New Landing Page',
  slug: 'new-landing-page',
  modules: [
    // Example starting modules (would be loaded from a template ideally)
    { id: 'mod1', type: 'TextBlock', content: '<h1>Headline Goes Here</h1><p>Edit this text.</p>' },
    { id: 'mod2', type: 'ImageBlock', src: 'https://via.placeholder.com/800x200', alt: 'Placeholder Image' },
    { id: 'mod3', type: 'ButtonBlock', text: 'Click Me', href: '#', style: 'primary' }, // Style would be brand-controlled
    { id: 'mod4', type: 'HtmlEmbedBlock', html: '<!-- Paste Marketo Form Embed Code Here -->'}
  ]
};
// ---------------

// --- Mock API Calls ---
const fetchPageData = async (pageId) => {
  console.log(`Fetching data for page: ${pageId}`);
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 300));
  if (pageId === 'new') {
    return JSON.parse(JSON.stringify(initialPageData)); // Return a copy
  }
  // TODO: Implement fetching existing page data
  return JSON.parse(JSON.stringify(initialPageData)); // Fallback for now
};

const savePageData = async (pageId, data) => {
  console.log(`Saving data for page: ${pageId}`, data);
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 500));
  // In a real app, this would return the saved data, maybe with updated IDs/timestamps
  return { success: true, pageId: pageId || `saved_${Date.now()}` };
};

const publishPage = async (pageId, data) => {
    console.log(`Publishing page: ${pageId}`, data);
    // Simulate API call to backend which handles build/deploy
    await new Promise(resolve => setTimeout(resolve, 1000));
    alert(`Page ${pageId} published successfully! (Simulated)`);
    return { success: true, url: `/published/${data.slug}` }; // Simulated URL
}
// ---------------


function EditorPage() {
  const { pageId } = useParams();
  const [pageData, setPageData] = useState(null);
  const [selectedModuleId, setSelectedModuleId] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);

  useEffect(() => {
    setIsLoading(true);
    fetchPageData(pageId).then(data => {
      setPageData(data);
      setIsLoading(false);
    });
  }, [pageId]); // Re-fetch if pageId changes

  const handleModuleUpdate = (moduleId, updatedProps) => {
    setPageData(prevData => ({
      ...prevData,
      modules: prevData.modules.map(mod =>
        mod.id === moduleId ? { ...mod, ...updatedProps } : mod
      )
    }));
  };

  const handlePageSettingsUpdate = (settings) => {
      setPageData(prevData => ({
          ...prevData,
          ...settings // e.g., { name: 'New Name' }
      }));
  }

  const handleSave = async () => {
    setIsSaving(true);
    const result = await savePageData(pageData.id, pageData);
    if (result.success && result.pageId !== pageData.id) {
        // Update pageData with new ID if it was a new page
        setPageData(prev => ({...prev, id: result.pageId}));
        // Optionally redirect or update URL? Maybe not needed if ID is internal.
    }
    setIsSaving(false);
    alert('Page saved! (Simulated)');
  };

    const handlePublish = async () => {
        // Ideally save before publishing or ensure it's saved
        await handleSave(); // Ensure latest is saved
        setIsSaving(true); // Use saving indicator for publish too
